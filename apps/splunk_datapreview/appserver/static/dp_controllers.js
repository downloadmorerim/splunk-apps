/**
 * Data preview subsystem
 *
 * This is the main entry point for all client-side datapreview functionality
 *
 */


// namespace in which to save all sourcetypes generated by the preview app
// value is either a string value for the namespace, i.e., 'splunk_datapreview'
// or 'system' for the local system global store
var SOURCETYPE_DESTINATION_NS = 'system';


Splunk.namespace("Splunk.preview");

Splunk.preview.Controller = function(filePath, continue_to, return_to, reset_to, dynLibs) {
    this.mysettings = new Splunk.preview.Settings();
    this.path = filePath;
    this.continue_to = continue_to;
    this.return_to = return_to;
    this.reset_to = reset_to;
    this.st_name = null;
    this.st_type = null;
    this.displayMode = 0; // unstructured by default
    this.displayModeChanged = false; 
    this.canChangeDisplayMode = true;
    this.isInitialSetup = true; // was current sourcetype automatically applied at the page load 
    this.error_panel = $('#main_error_panel');
    this.userHasApplied = false;
    this.chartingLibLoaded = false;
    this.pendingMetadata = null;
    this.dynLibs = dynLibs;
    this.MODE_SOURCETYPE_MAP = {0: '', 1: 'csv', 2: '_json', 3: 'iis'};
    this.DELIMITER_EXTRACTION_MAP = {',':'csv', '|':'psv', 'tab':'tsv'};

};

Splunk.preview.Controller.prototype = {

    main: function() {
        var that = this;
        // load dynamic libraries
        $script(this.dynLibs, $.proxy(function() {
            this.chartingLibLoaded = true;
            if (this.pendingMetadata) {
                metaview.render(this.pendingMetadata);
                this.pendingMetadata = null;
            }
        },this));
    
        // Event bindings
        $('.ts_apply').on('click', $.proxy(this.handleApply, this));
        $('.resetSettings').on('click', $.proxy(this.handleReset, this));
        
        $('a#continue').bind('click', $.proxy(this.handleContinue, this));
        $('#bt_continue').bind('click', $.proxy(this.handleContinue, this));
        $('#bt_cancel').bind('click', $.proxy(this.goFilePicker, this));
        
        $('#display_mode_switch').bind('change', function() {
            that.setDisplayMode($(this).val());
        });

        $('#go_raw').bind('click', function(evt) {
            that.setDisplayMode(0);
            evt.preventDefault();
        });
        
        confview.updateSettings();
        confview.render();
        
        stview.bind('submit', $.proxy(function() {
            this.st_type = stview.getSelectionValue();
            
            if (this.st_type == 'auto') {
                this.st_name = stview.autoSourcetype;
                confview.disableDisplayMode();
            } else if (this.st_type == 'new') {
                this.mysettings.set('sourcetype', '');
                if (stview.autoSourcetype) {
                    // only refresh when preview was loaded with 
                    // an automatically detected sourcetype
                    //this.renderViews();
                    that.setDisplayMode(0);
                }
                
            } else if (this.st_type == 'existing') {
                this.st_name = stview.getPresetValue();
                this.canChangeDisplayMode = false;
                this.mysettings.set('sourcetype', this.st_name);
                this.isInitialSetup = true; 
                this.renderViews();
            }
        }, this));
        
        // Begin loading data
        $.when(
            Splunk.preview.Sourcetype.fetchNames()
                .pipe(function(values) {
                    stview.presetValues = values;
                })
            ,
            this.renderViews()
            )
        .then($.proxy(function(f1, f2) {
            var str = this.path,
                suffix = '.json';
            // if filename ends with .json, we 'autodetect' _json sourcetype manually
            if (str.indexOf(suffix, str.length - suffix.length) !== -1) {
                stview.autoSourcetype = '_json';
                that.setDisplayMode(2);
            } else {
                stview.autoSourcetype = samp.settings.get('PREFERRED_SOURCETYPE');
            }
            stview.render(this);
        },this));
        
    },
    
    /**
     * Send user to preview file selection page
     */
    goFilePicker: function() {
        if (this.reset_to.length == 0) {
            history.go(-1);
        }
        var path_query = this.reset_to.split('?');
        var props = {};
        if (path_query.length > 1) {
            props = Splunk.util.queryStringToProp(path_query[1]);
        } 
        props.source = this.path;
        if (props.hasOwnProperty('breadcrumbs')) {
            props.breadcrumbs = props.breadcrumbs.replace('+',' ');
        }
        var redirect_url = path_query[0] + '?' + $.param(props);
        window.location.href = redirect_url;
    },

    /**
     * Starts the various requests to fetch data
     */
    renderViews: function() {
        eventview.clear();
        eventStructview.clear();
        metaview.clear();
        
        eventview.showThrobber();
        eventStructview.showThrobber();

        // get sample from URI
        return Splunk.preview.createSample(this.path, this.mysettings)
            .pipe(
                $.proxy(function(sample) {
                    samp = sample;
                    
                    // by default we render in unstructured mode. Here's an exception for structured sourcetypes.
                    if (this.isInitialSetup) {
                        var indexedExtractions = !!this.mysettings.get('INDEXED_EXTRACTIONS') ? this.mysettings.get('INDEXED_EXTRACTIONS').toLowerCase() : '',
                            silent = this.isInitialSetup;
                        if (['csv','tsv','psv'].indexOf(indexedExtractions) > -1) {
                            this.setDisplayMode(1, silent);
                        } else if (indexedExtractions == 'json') {
                            this.setDisplayMode(2, silent);
                        } else if (indexedExtractions == 'w3c') {
                            this.setDisplayMode(3, silent);
                        } else {
                            this.setDisplayMode(0, silent);
                        }
                        this.isInitialSetup = false;
                    }
                    
                    if (!this.canChangeDisplayMode) {
                        confview.disableDisplayMode();
                    }
                    confview.loadProps(sample.settings);
                    confview.updateSettings();
                    var job = sample.initSearchJob();
                    $(job).bind('stateChange', $.proxy(this.handleJobStateChange, this));
                    $(job).bind('propertiesUpdate', $.proxy(this.handleJobPropertiesUpdate, this));
                    job.startPoll();
                }, this)
            ,
                $.proxy(function(error_info) {
                    // error_info.messages
                    // error_info.statusCode
                    // error_info.errorThrown
                    var strings = [];
                    $.each(error_info.messages, function(ix,msg) { 
                        if (msg.type != 'HTTP') {
                            strings.push(msg.text); 
                        }
                    });
                    this.promptFatalError(strings);
                }, this)
            );


    },


    showErrors: function(messages) {
        if (messages && messages.length) {
            // TODO: this truncation is temporary; need to refactor messaging
            this.error_panel.text(messages.slice(0,2).join('; '));
        }
    },


    clearErrors: function() {
        this.error_panel.html('');
    },
        
    showNoResults: function() {
        if (typeof this.displayMode == "undefined" || this.displayMode == '0') {
            eventview.showNoResults();
        } else {
            eventStructview.showNoResults();
        }
    },
        
    promptFatalError: function(messages) {
        eventview.clearThrobber();
        
        var errorList = $('#fatal_popup ul').html('');
        var i,L;
        for (i=0,L=messages.length; i<L; i++) {
            errorList.append($('<li/>').text(messages[i]));
        }

        // determine the right buttons to show on error
        var buttons = [
                {
                    label: _('Select a different file'),
                    type: 'primary',
                    callback: $.proxy(this.goFilePicker, this)
                }
        ];

        if (this.isInitialSetup) {
            var fatalPopup = new Splunk.Popup($('#fatal_popup'), {
                title: _('Error processing file'),
                buttons: buttons
            });
        }
    },

        
    handleJobPropertiesUpdate: function(evt) {
        if (samp.searchJob.get('doneProgress') != null) {
            eventview.setProgress(samp.searchJob.get('doneProgress'));
        }
    },

    /**
     * Fills in rest of data when job finishes
     */
    handleJobStateChange: function(evt, state) {
        var that = this;
        if (state >= splunk.service.JobStates.DONE) {

            // deal with job messaging
            var jobMessages = samp.searchJob.get('messages');
            var desiredLevels = ['error', 'warn', 'info'];
            var outputText = [];
            var i,L;
            for (var i=0,L=desiredLevels.length; i<L; i++) {
                if (jobMessages[desiredLevels[i]]) {
                    outputText = outputText.concat(jobMessages[desiredLevels[i]]);
                }
            }
            this.showErrors(outputText);

            // assume that errors on job mean something is busted
            if (samp.searchJob.get('eventCount') == 0 
                || samp.searchJob.get('isFailed')
                || samp.searchJob.get('isZombie')
                || jobMessages.error 
            ) {
                if (samp.searchJob.get('doneProgress') == 0) {
                    // suppressing a false alert when job state has changed
                    // but sample's search job is not done (SPL-50067)
					return;
				}
                eventview.clearThrobber();
                metaview.clearThrobber();
                stview.close();
                if (!outputText.length) {
                    outputText = [_('Could not generate a preview of this file.')];
                }
                this.showNoResults();
                
                this.promptFatalError(outputText);

            } else {
                if (!this.userHasApplied ) {
                    this.originalSettings = $.extend({}, samp.settings);
                }
                samp.fetchEvents()
                    .pipe(function(output) {
                        eventview.clearThrobber();
                        if (typeof that.displayMode == "undefined" || that.displayMode == '0') {
                            eventview.render(output.events);
                        } else {
                            eventStructview.render(output);
                        }
                        
                    })
                    .pipe(function() {
                        metaview.showThrobber();
                        return samp.fetchMetadata();
                    })
                    .pipe($.proxy(function(results) {
                        metaview.clearThrobber();
                        if (this.chartingLibLoaded) {
                            metaview.render(results);
                        } else {
                            this.pendingMetadata = results;
                        }
                    },this));
            }
        }
    },
    
    setDisplayMode: function(mode, silent) {
        if (this.displayMode == mode) { // noop
            return;
        }
        this.displayMode = mode;
        if (!silent) {
            // let the initial setup to set silently, so it won't be treated as a user's change
            this.displayModeChanged = true;
            this.mysettings.clear();
            this.mysettings.set('sourcetype', this.MODE_SOURCETYPE_MAP[mode]);
            if (mode == 0) {
                this.mysettings.set('INDEXED_EXTRACTIONS', '');
            }
            confview.resetSettings(); 
        }
        this.clearErrors();
        confview.setDisplayMode(mode);
        eventStructview.hideNoResults();
        
        this.st_name = this.MODE_SOURCETYPE_MAP[mode];
        
        this.renderViews();
    },
    
    handleApply: function (evt) {
        if (evt) {
            evt.preventDefault();
        }
        
        // first reset
        this.mysettings.clear();
        this.clearErrors();
        this.userHasApplied = true;

        this.processConfig();
        this.renderViews();
        return true;
    },
    
    handleReset: function (evt) {
        if (evt) {
            evt.preventDefault();
        }
        
        confview.resetSettings(); 
        this.handleApply();   

        return true;
    },
    
    handleContinue: function () {
        if (confview.settingsChanged()) {
            var shouldApply = confirm(_('You have unapplied changes. Would you like to apply them now?'));
            if (shouldApply) {
                this.handleApply();
            }
            return false;
        }
        if ((this.st_type == 'auto' || this.st_type == 'existing') && !this.userHasApplied) {
            var redirect_url = this.makeContinueUrl(this.st_name);
            window.location.href = redirect_url;
            
        } else {
            stconfirm.render(this.mysettings, this.makeContinueUrl(), this.return_to);    
        }
    },

    handleSubmit: function() {
        stconfirm.clearErrors();
        var st_name = $('#st_name').val();
        if (!st_name) {
            stconfirm.showError(_('Provide a source type name'));
            return;
        }

        // set flag so that this sourcetype will show up in future lists
        // of "available" sourcetypes
        var settingsToSave = this.mysettings.toSourcetypeSettings();
        settingsToSave['pulldown_type'] = 1;
        
        // empty settings would be ignored by the indexer, however preview needs them to
        // 'delete' settings coming from an existing sourcetype, hence this hack
        var s;
        for (s in settingsToSave) {
            if (settingsToSave[s] === '') {
                delete settingsToSave[s];
            }
        }
        
        var src = new Splunk.preview.Sourcetype(
            SOURCETYPE_DESTINATION_NS, 
            Splunk.util.getConfigValue('USERNAME'), 
            settingsToSave);
        
        src.save(st_name)
            .done($.proxy(function(saved_object) {
                stconfirm.close();
                stsuccess.render(st_name, this.makeContinueUrl(st_name), this.return_to);
            }, this))

            .fail(function(err) {
                var err_msg;
                if (err.statusCode == 409) {
                    err_msg = _('This source type already exists. Please enter a different name.');
                }
                else {
                    err_msg = _('Save failed: ') + $.map(err.messages, function(x){return x.text;}).join('; ');
                }
                stconfirm.showError(err_msg);
            });
    },
    

    processConfig: function() {
        // make sure to first set the simple, then override with any user-set
        // keys from the advanced box
        this._processSimpleConfig();
        this._processAdvancedConfig();
        confview.updateSettings();
    },
     
    // sets each setting from the list to empty value unless it was empty or undefined in the original sourcetype
    _resetIfChanged: function(settings, list) {
        if (!list || !settings) {
            return;
        }
        for (var i=0; i<list.length; i++) {
            var key = list[i];
            if (typeof this.originalSettings.get(key) == 'undefined' || this.originalSettings.get(key) === '') {
                continue;
            }
            settings.set(key, '');
        }
    },
     
    // post-processing serialized form values and copying result to mysettings
    _processSimpleConfig: function()  {
        var simpleSettings = confview.getSimpleSettings();
        
        
        // setting INDEXED_EXTRACTIONS by the selected delimiter
        if (this.displayMode == 1 && 'FIELD_DELIMITER' in simpleSettings) {
            simpleSettings['INDEXED_EXTRACTIONS'] = this.DELIMITER_EXTRACTION_MAP[simpleSettings['FIELD_DELIMITER']] || 'csv';
        }
        $.each(simpleSettings, $.proxy(function(key, val){
            if ( key in Splunk.preview.Settings.properties && val === '' && 
                 (typeof this.originalSettings.get(key) == 'undefined' || this.originalSettings.get(key) === '') ) { 
                // skip empty values that were unchanged
                return 
            }
            
            if ( key == 'lb_type' ) {
                if (val === '') {
                    this._resetIfChanged(this.mysettings, ['SHOULD_LINEMERGE','BREAK_ONLY_BEFORE']);
                } else if ( val === 'single_line' ) {
                    this.mysettings.set('SHOULD_LINEMERGE', 'false');
                    this._resetIfChanged(this.mysettings, ['BREAK_ONLY_BEFORE']);
                } else if ( val === 'regex' ) {
                    this.mysettings.set('SHOULD_LINEMERGE', 'true');
                } 
                
            } else if ( key=== 'ts_type' || key === 'str_ts_type' ) {
                if (val == 'curtime') {
                    this.mysettings.set('DATETIME_CONFIG', 'CURRENT');
                    this._resetIfChanged(this.mysettings, ['TIME_PREFIX','TIMESTAMP_FIELDS']);
                } else {
                    if (val === '') {
                        this._resetIfChanged(this.mysettings, ['TIME_PREFIX','TIMESTAMP_FIELDS']);
                    }
                    if (this.mysettings.get('DATETIME_CONFIG') == 'CURRENT') {
                        this._resetIfChanged(this.mysettings, ['DATETIME_CONFIG']);
                    }
                }
            } else if ( key=== 'hdr_type' ) {
                if (val === '') {
                    this._resetIfChanged(this.mysettings, ['FIELD_HEADER_REGEX','HEADER_FIELD_LINE_NUMBER','FIELD_NAMES']);
                } else if (val === 'pattern') {
                    this._resetIfChanged(this.mysettings, ['HEADER_FIELD_LINE_NUMBER','FIELD_NAMES']);
                } else if (val === 'line') {
                    this._resetIfChanged(this.mysettings, ['FIELD_HEADER_REGEX','FIELD_NAMES']);
                } else if (val === 'direct') {
                    this._resetIfChanged(this.mysettings, ['FIELD_HEADER_REGEX','HEADER_FIELD_LINE_NUMBER']);
                } 
            } else {
                if (key in Splunk.preview.Settings.properties) {
                    // filter out non-props form entities
                    this.mysettings.set(key, val);
                }
            }
        }, this));
    },

    _processAdvancedConfig: function() {
        var propsData = confview.getAdvancedSettings();
        var rows = propsData.split('\n');
        $.each(rows, $.proxy(function(ix,row) {
            // SPL-76596 allow '=' to be part of value. eg TIME_PREFIX = timestamp= 
            var n = row.indexOf("=");
            if(n > 0 ) {
                this.mysettings.set(row.substr(0, n), row.substr(n + 1));
            }
        }, this));
    },
    

    /**
     * Returns a relative URI that points to a data input creation page with:
     * - the "more settings" tab open
     * - the sourcetype mode set to "manual"
     * - the sourcetype name set to the sourcetype parameter
     * - (file input) the input path set to the sample filepath
     *
     */ 
    makeContinueUrl: function(sourcetype) {

        // set defaults
        var sourcetype = sourcetype || '';
        var path = Splunk.util.make_url('/manager/search/data/inputs/monitor/_new');
        var query_string = {
            'action': 'edit',
            'redirect_override_cancel': Splunk.util.getPath(this.return_to),
            'def.sourcetype': sourcetype,
            'def.spl-ctrl_sourcetypeSelect': 'sourcetype',
            'def.spl-ctrl_EnableAdvanced': '1'
        };
                              
        // assume that page will generally have continue links
        if (this.continue_to && this.continue_to.indexOf('?') > -1) {
            var continue_parts = this.continue_to.split('?');
            path = continue_parts[0];
            query_string = $.extend(query_string, Splunk.util.queryStringToProp(continue_parts[1]));
        }

        // only file monitor can get the name prepopulated; all other input
        // types have different needs
        if (path.indexOf('inputs/monitor') > -1) {
            query_string['def.name'] = this.path;
        }

        return path + '?' + Splunk.util.propToQueryString(query_string);

    }

    

    
};


window.eventview = new Splunk.preview.EventView();
window.eventStructview = new Splunk.preview.EventStructView();
window.metaview = new Splunk.preview.MetadataView();
window.confview = new Splunk.preview.ConfigurationView();
window.stview = new Splunk.preview.SourcetypeModeView();
window.stconfirm = new Splunk.preview.SourcetypeConfirmView();
window.stsuccess = new Splunk.preview.SourcetypeSuccessView();

